{ 
	// all DSA Codes
	// Place your snippets for c here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	// DS
	"queue2": {
		"prefix": "helpqueue2",
		"body": [
			"#include <limits.h>",
			"#include <stdio.h>",
			"#include <stdlib.h>",
			"",
			"// A structure to represent a queue",
			"struct Queue {",
			"	int front, rear, size;",
			"	unsigned capacity;",
			"	int* array;",
			"};",
			"",
			"// function to create a queue",
			"// of given capacity.",
			"// It initializes size of queue as 0",
			"struct Queue* createQueue(unsigned capacity)",
			"{",
			"	struct Queue* queue = (struct Queue*)malloc(",
			"		sizeof(struct Queue));",
			"	queue->capacity = capacity;",
			"	queue->front = queue->size = 0;",
			"",
			"	// This is important, see the enqueue",
			"	queue->rear = capacity - 1;",
			"	queue->array = (int*)malloc(",
			"		queue->capacity * sizeof(int));",
			"	return queue;",
			"}",
			"",
			"// Queue is full when size becomes",
			"// equal to the capacity",
			"int isFull(struct Queue* queue)",
			"{",
			"	return (queue->size == queue->capacity);",
			"}",
			"",
			"// Queue is empty when size is 0",
			"int isEmpty(struct Queue* queue)",
			"{",
			"	return (queue->size == 0);",
			"}",
			"",
			"// Function to add an item to the queue.",
			"// It changes rear and size",
			"void enqueue(struct Queue* queue, int item)",
			"{",
			"	if (isFull(queue))",
			"		return;",
			"	queue->rear = (queue->rear + 1)",
			"				% queue->capacity;",
			"	queue->array[queue->rear] = item;",
			"	queue->size = queue->size + 1;",
			"	printf(\"%d enqueued to queue\\n\", item);",
			"}",
			"",
			"// Function to remove an item from queue.",
			"// It changes front and size",
			"int dequeue(struct Queue* queue)",
			"{",
			"	if (isEmpty(queue))",
			"		return INT_MIN;",
			"	int item = queue->array[queue->front];",
			"	queue->front = (queue->front + 1)",
			"				% queue->capacity;",
			"	queue->size = queue->size - 1;",
			"	return item;",
			"}",
			"",
			"// Function to get front of queue",
			"int front(struct Queue* queue)",
			"{",
			"	if (isEmpty(queue))",
			"		return INT_MIN;",
			"	return queue->array[queue->front];",
			"}",
			"",
			"// Function to get rear of queue",
			"int rear(struct Queue* queue)",
			"{",
			"	if (isEmpty(queue))",
			"		return INT_MIN;",
			"	return queue->array[queue->rear];",
			"}",
			"",
			"// Driver program to test above functions./",
			"int main()",
			"{",
			"	struct Queue* queue = createQueue(1000);",
			"",
			"	enqueue(queue, 10);",
			"	enqueue(queue, 20);",
			"	enqueue(queue, 30);",
			"	enqueue(queue, 40);",
			"",
			"	printf(\"%d dequeued from queue\\n\\n\",",
			"		dequeue(queue));",
			"",
			"	printf(\"Front item is %d\\n\", front(queue));",
			"	printf(\"Rear item is %d\\n\", rear(queue));",
			"",
			"	return 0;",
			"}"
		],
		"description": "queue2"
	},
	"queue": {
		"prefix": "helpqueue",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			" ",
			"",
			"struct Queue {",
			"",
			"    stack<int> s1, s2;",
			" ",
			"",
			"    void enQueue(int x)",
			"",
			"    {",
			"",
			"        // Move all elements from s1 to s2",
			"",
			"        while (!s1.empty()) {",
			"",
			"            s2.push(s1.top());",
			"",
			"            s1.pop();",
			"",
			"        }",
			" ",
			"",
			"        // Push item into s1",
			"",
			"        s1.push(x);",
			" ",
			"",
			"        // Push everything back to s1",
			"",
			"        while (!s2.empty()) {",
			"",
			"            s1.push(s2.top());",
			"",
			"            s2.pop();",
			"",
			"        }",
			"",
			"    }",
			" ",
			"",
			"    // Dequeue an item from the queue",
			"",
			"    int deQueue()",
			"",
			"    {",
			"",
			"        // if first stack is empty",
			"",
			"        if (s1.empty()) {",
			"",
			"            cout << \"Q is Empty\";",
			"",
			"            exit(0);",
			"",
			"        }",
			" ",
			"",
			"        // Return top of s1",
			"",
			"        int x = s1.top();",
			"",
			"        s1.pop();",
			"",
			"        return x;",
			"",
			"    }",
			"};",
			" ",
			"// Driver code",
			"",
			"int main()",
			"{",
			"",
			"    Queue q;",
			"",
			"    q.enQueue(1);",
			"",
			"    q.enQueue(2);",
			"",
			"    q.enQueue(3);",
			" ",
			"",
			"    cout << q.deQueue() << '\\n';",
			"",
			"    cout << q.deQueue() << '\\n';",
			"",
			"    cout << q.deQueue() << '\\n';",
			" ",
			"",
			"    return 0;",
			"}"
		],
		"description": "queue"
	},
	"ds stack+ queue": {
		"prefix": "dsstack",
		"body": [
			"/* C program to implement queues using two stacks */",
			"#include <stdio.h>",
			"#include <stdlib.h>",
			"struct node",
			"{",
			"    int data;",
			"    struct node *next;",
			"};",
			"void push(struct node** top, int data);",
			"int pop(struct node** top);",
			"struct queue",
			"{",
			"    struct node *stack1;",
			"    struct node *stack2;",
			"};",
			"void enqueue(struct queue *q, int x)",
			"{",
			"    push(&q->stack1, x);",
			"}",
			"void dequeue(struct queue *q)",
			"{",
			"    int x;",
			"    if (q->stack1 == NULL && q->stack2 == NULL) {",
			"        printf(\"queue is empty\");",
			"        return;",
			"    }",
			"    if (q->stack2 == NULL) {",
			"        while (q->stack1 != NULL) {",
			"        x = pop(&q->stack1);",
			"        push(&q->stack2, x);",
			"        }",
			"    }",
			"    x = pop(&q->stack2);",
			"    printf(\"%d\\n\", x);",
			"}",
			"void push(struct node** top, int data)",
			"{",
			"    struct node* newnode = (struct node*) malloc(sizeof(struct node));",
			"        if (newnode == NULL) {",
			"            printf(\"Stack overflow \\n\");",
			"            return;",
			"        }",
			"    newnode->data = data;",
			"    newnode->next = (*top);",
			"    (*top) = newnode;",
			"}",
			"int pop(struct node** top)",
			"{",
			"    int buff;",
			"    struct node *t;",
			"    if (*top == NULL) {",
			"        printf(\"Stack underflow \\n\");",
			"        return;",
			"    }",
			"    else {",
			"        t = *top;",
			"        buff = t->data;",
			"        *top = t->next;",
			"        free(t);",
			"        return buff;",
			"    }",
			"}",
			"void display(struct node *top1,struct node *top2)",
			"{",
			"    while (top1 != NULL) {",
			"        printf(\"%d\\n\", top1->data);",
			"        top1 = top1->next;",
			"    }",
			"    while (top2 != NULL) {",
			"        printf(\"%d\\n\", top2->data);",
			"        top2 = top2->next;",
			"    }",
			"}",
			"int main()",
			"{",
			"    struct queue q = (struct queue)malloc(sizeof(struct queue));",
			"    int f = 0, a;",
			"    char ch = 'y';",
			"    q->stack1 = NULL;",
			"    q->stack2 = NULL;",
			"    while (ch == 'y'||ch == 'Y') {",
			"        printf(\"enter ur choice\\n1.add to queue\\n2.remove ",
			"               from queue\\n3.display\\n4.exit\\n\");",
			"        scanf(\"%d\", &f);",
			"        switch(f) {",
			"            case 1 : printf(\"enter the element to be added to queue\\n\");",
			"                     scanf(\"%d\", &a);",
			"                     enqueue(q, a);",
			"                     break;",
			"            case 2 : dequeue(q);",
			"                     break;",
			"            case 3 : display(q->stack1, q->stack2);",
			"                     break;",
			"            case 4 : exit(1);",
			"                     break;",
			"            default : printf(\"invalid\\n\");",
			"                      break;",
			"        }",
			"    }",
			"}"
		],
		"description": "ds stack+ queue"
	},
  // Array.. 
	"Print Array": {
		"prefix": "arrprint",
		"body": [
			"void print_arr(int arr[], int size)",
			"{",
			"  int i;",
			"  for (i = 0; i < size; i++)",
			"    printf(\"%d \", arr[i]);",
			"  printf(\"\\n\");",
			"}"
		],
		"description": "Print Array"
	},
	// binary Search tree...
	"IsBst tree": {
		"prefix": "oneisBST",
		"body": [
			"",
			"",
			"#include <stdio.h>",
			"#include <stdlib.h>",
			"",
			"struct node {",
			"  int key;",
			"  struct node *left, *right;",
			"};",
			"",
			"// Create a node",
			"struct node *newNode(int item) {",
			"  struct node *temp = (struct node *)malloc(sizeof(struct node));",
			"  temp->key = item;",
			"  temp->left = temp->right = NULL;",
			"  return temp;",
			"}",
			"",
			"// Inorder Traversal",
			"void inorder(struct node *root) {",
			"  if (root != NULL) {",
			"    // Traverse left",
			"    inorder(root->left);",
			"",
			"    // Traverse root",
			"    printf(\"%d -> \", root->key);",
			"",
			"    // Traverse right",
			"    inorder(root->right);",
			"  }",
			"}",
			"",
			"// Insert a node",
			"struct node *insert(struct node *node, int key) {",
			"  // Return a new node if the tree is empty",
			"  if (node == NULL) return newNode(key);",
			"",
			"  // Traverse to the right place and insert the node",
			"  if (key < node->key)",
			"    node->left = insert(node->left, key);",
			"  else",
			"    node->right = insert(node->right, key);",
			"",
			"  return node;",
			"}",
			"",
			"// Find the inorder successor",
			"struct node *minValueNode(struct node *node) {",
			"  struct node *current = node;",
			"",
			"  // Find the leftmost leaf",
			"  while (current && current->left != NULL)",
			"    current = current->left;",
			"",
			"  return current;",
			"}",
			"",
			"// Deleting a node",
			"struct node *deleteNode(struct node *root, int key) {",
			"  // Return if the tree is empty",
			"  if (root == NULL) return root;",
			"",
			"  // Find the node to be deleted",
			"  if (key < root->key)",
			"    root->left = deleteNode(root->left, key);",
			"  else if (key > root->key)",
			"    root->right = deleteNode(root->right, key);",
			"",
			"  else {",
			"    // If the node is with only one child or no child",
			"    if (root->left == NULL) {",
			"      struct node *temp = root->right;",
			"      free(root);",
			"      return temp;",
			"    } else if (root->right == NULL) {",
			"      struct node *temp = root->left;",
			"      free(root);",
			"      return temp;",
			"    }",
			"",
			"    // If the node has two children",
			"    struct node *temp = minValueNode(root->right);",
			"",
			"    // Place the inorder successor in position of the node to be deleted",
			"    root->key = temp->key;",
			"",
			"    // Delete the inorder successor",
			"    root->right = deleteNode(root->right, temp->key);",
			"  }",
			"  return root;",
			"}",
			"",
			"// Driver code",
			"int main() {",
			"  struct node *root = NULL;",
			"  root = insert(root, 11);",
			"  root = insert(root, 6);",
			"  root = insert(root, 4);",
			"  root = insert(root, 9);",
			"  root = insert(root, 10);",
			"  root = insert(root, 13);",
			"  root = insert(root, 17);",
			"  root = insert(root, 7);",
			"",
			"  printf(\"Inorder traversal: \");",
			"  inorder(root);",
			"",
			"  printf(\"\\nAfter deleting 10\\n\");",
			"  root = deleteNode(root, 10);",
			"  printf(\"Inorder traversal: \");",
			"  inorder(root);",
			"}"
		],
		"description": "// Binary Search Tree operations in C"
	},
	"Tower of Hanoi": {
		"prefix": "helptower",
		"body": [
			"#include<stdio.h>",
			"void TOH(int n,char x,char y,char z) {",
			"   if(n>0) {",
			"      TOH(n-1,x,z,y);",
			"      printf(\"\\n%c to %c\",x,y);",
			"      TOH(n-1,z,y,x);",
			"   }",
			"}",
			"int main() {",
			"   int n=3;",
			"   TOH(n,'J','K','L');",
			"   return 0;",
			"}"
		],
		"description": "Tower of Hanoi"
	},
	// Tree Traversal..
	"tree node": {
		"prefix": "treenode",
		"body": [
			"struct node {",
			"  int data;",
			"  struct node* left;",
			"  struct node* right;",
			"};",
			""
		],
		"description": "tree node"
	},
	"tree new node": {
		"prefix": "treenewnode",
		"body": [
			"struct node* newNode(int data)",
			"{",
			"  struct node* node",
			"    = (struct node*)malloc(sizeof(struct node));",
			"  node->data = data;",
			"  node->left = NULL;",
			"  node->right = NULL;",
			"",
			"  return (node);",
			"}",
			""
		],
		"description": "tree new node"
	},
	"Inorder Print": {
		"prefix": "treein",
		"body": [
			"void printInorder(struct node* node)",
			"{",
			"  if (node == NULL)",
			"    return;",
			"  printInorder(node->left);",
			"  printf(\"%d \", node->data);",
			"  printInorder(node->right);",
			"}"
		],
		"description": "Inorder Print"
	},
	"Tree drive ": {
		"prefix": "treedriver",
		"body": [
			"int main()",
			"{",
			"  struct node* root = newNode(1);",
			"  root->left = newNode(2);",
			"  root->right = newNode(3);",
			"  root->left->left = newNode(4);",
			"  root->left->right = newNode(5);",
			"  printInorder(root);",
			"  ",
			"  return 0;",
			"}"
		],
		"description": "Tree "
	},
	"Tree Pre": {
		"prefix": "treepre",
		"body": [
			"void printPreorder(struct node* node)",
			"{",
			"  if (node == NULL)",
			"    return;",
			"  printf(\"%d \", node->data);",
			"  printPreorder(node->left);",
			"  printPreorder(node->right);",
			"}"
		],
		"description": "Tree Pre"
	},
	"Tree Post": {
		"prefix": "treepo",
		"body": [
			"void printPostorder(struct node* node)",
			"{",
			"  if (node == NULL)",
			"    return;",
			"  printPostorder(node->left);",
			"  printPostorder(node->right);",
			"  printf(\"%d \", node->data);",
			"}",
			""
		],
		"description": "Tree Post"
	},
	// Singly linked list codes...
  "sll node": {
		"prefix": "sllnode",
		"body": [
			"struct node  ",
			"{  ",
			"    int data;  ",
			"    struct node *next;  ",
			"}; "
			"struct node *head;"
		],
		"description": "sll node"
	},
	"sll begin insert": {
		"prefix": "sllbegininsert",
		"body": [
			"void beginsert(int x)  ",
			"    {  ",
			"        struct node *ptr = (struct node *)malloc(sizeof(struct node *));  ",
			"        if(ptr == NULL)  ",
			"        {  ",
			"            printf(\"OVERFLOW\");  ",
			"        }  ",
			"        else  ",
			"        {  ",
			"            ptr->data = x;  ",
			"            ptr->next = head;  ",
			"            head = ptr;  ",
			"        }  ",
			"          ",
			"    }  "
		],
		"description": "sll begin insert"
	},
	"sll drive": {
		"prefix": "sll drive",
		"body": [
			"int main(){",
			"      struct node* head= malloc(sizeof(struct node));",
			"      head->data=54;",
			"      head->next=NULL;",
			"      struct node *cur= malloc(sizeof(struct node));",
			"      cur->data=33;",
			"      head->next=cur;",
			"      ",
			"      return 0;",
			"    }"
		],
		"description": "sll drive"
	},
	"sll delf": {
		"prefix": "slldelf",
		"body": [
			"struct node* del_first(struct node *head){",
			"  if(head==NULL){",
			"    //emptyprint",
			"  }",
			"  else{",
			"    struct node *temp=head;",
			"    head =head->next;",
			"    free(temp);",
			"    temp=NULL;",
			"",
			"  }",
			"  return head;",
			"}"
		],
		"description": "sll delf"
	},
	"sll drive2": {
		"prefix": "slldrive",
		"body": [
			"int main(){",
			"  head=del_first(head);",
			"  ptr=head;",
			"  while(ptr!=NULL){",
			"    //pr ptr->data",
			"    ptr=ptr->next;",
			"  }",
			"  return 0;",
			"}"
		],
		"description": "sll drive"
	},
	"sll dell": {
		"prefix": "slldell",
		"body": [
			"struct node* del_last(struct node* head){",
			"  if(head==NULL)// empty",
			"  else if(head->next ==NULL){",
			"    free(head);",
			"    head=NULL;",
			"  }",
			"  else{",
			"    struct node *temp= head;",
			"    struct node *temp2=head;",
			"    while(temp->link !=NULL){",
			"      temp2=temp;",
			"      temp=temp->next;",
			"    }",
			"    temp2->next =NULL;",
			"    free(temp);",
			"    temp=NULL;",
			"    return head;",
			"  }",
			"}"
		],
		"description": "sll dell"
	},
	"sll help": {
		"prefix": "sllhelp",
		"body": [
			"// C program for the all operations in",
			"// the Doubly Linked List",
			"#include <stdio.h>",
			"#include <stdlib.h>",
			"",
			"// Linked List Node",
			"struct node {",
			"	int info;",
			"	struct node *prev, *next;",
			"};",
			"struct node* start = NULL;",
			"",
			"// Function to traverse the linked list",
			"void traverse()",
			"{",
			"	// List is empty",
			"	if (start == NULL) {",
			"		printf(\"\\nList is empty\\n\");",
			"		return;",
			"	}",
			"	// Else print the Data",
			"	struct node* temp;",
			"	temp = start;",
			"	while (temp != NULL) {",
			"		printf(\"Data = %d\\n\", temp->info);",
			"		temp = temp->next;",
			"	}",
			"}",
			"",
			"// Function to insert at the front",
			"// of the linked list",
			"void insertAtFront()",
			"{",
			"	int data;",
			"	struct node* temp;",
			"	temp = (struct node*)malloc(sizeof(struct node));",
			"	printf(\"\\nEnter number to be inserted: \");",
			"	scanf(\"%d\", &data);",
			"	temp->info = data;",
			"	temp->prev = NULL;",
			"",
			"	// Pointer of temp will be",
			"	// assigned to start",
			"	temp->next = start;",
			"	start = temp;",
			"}",
			"",
			"// Function to insert at the end of",
			"// the linked list",
			"void insertAtEnd()",
			"{",
			"	int data;",
			"	struct node *temp, *trav;",
			"	temp = (struct node*)malloc(sizeof(struct node));",
			"	temp->prev = NULL;",
			"	temp->next = NULL;",
			"	printf(\"\\nEnter number to be inserted: \");",
			"	scanf(\"%d\", &data);",
			"	temp->info = data;",
			"	temp->next = NULL;",
			"	trav = start;",
			"",
			"	// If start is NULL",
			"	if (start == NULL) {",
			"",
			"		start = temp;",
			"	}",
			"",
			"	// Changes Links",
			"	else {",
			"		while (trav->next != NULL)",
			"			trav = trav->next;",
			"		temp->prev = trav;",
			"		trav->next = temp;",
			"	}",
			"}",
			"",
			"// Function to insert at any specified",
			"// position in the linked list",
			"void insertAtPosition()",
			"{",
			"	int data, pos, i = 1;",
			"	struct node *temp, *newnode;",
			"	newnode = malloc(sizeof(struct node));",
			"	newnode->next = NULL;",
			"	newnode->prev = NULL;",
			"",
			"	// Enter the position and data",
			"	printf(\"\\nEnter position : \");",
			"	scanf(\"%d\", &pos);",
			"	",
			"",
			"	// If start==NULL,",
			"	if (start == NULL) {",
			"		start = newnode;",
			"		newnode->prev = NULL;",
			"		newnode->next = NULL;",
			"	}",
			"",
			"	// If position==1,",
			"	else if (pos == 1) {",
			"	// this is author method its correct but we can simply call insertAtfront() function for this special case",
			"	/* newnode->next = start;",
			"		newnode->next->prev = newnode;",
			"		newnode->prev = NULL;",
			"		start = newnode; */",
			"	// now this is improved by Jay Ghughriwala on geeksforgeeks",
			"	insertAtFront();",
			"	}",
			"",
			"	// Change links",
			"	else {",
			"	printf(\"\\nEnter number to be inserted: \");",
			"	scanf(\"%d\", &data);",
			"	newnode->info = data;",
			"	temp = start;",
			"		while (i < pos - 1) {",
			"			temp = temp->next;",
			"			i++;",
			"		}",
			"		newnode->next = temp->next;",
			"		newnode->prev = temp;",
			"		temp->next = newnode;",
			"		temp->next->prev = newnode;",
			"	}",
			"}",
			"",
			"// Function to delete from the front",
			"// of the linked list",
			"void deleteFirst()",
			"{",
			"	struct node* temp;",
			"	if (start == NULL)",
			"		printf(\"\\nList is empty\\n\");",
			"	else {",
			"		temp = start;",
			"		start = start->next;",
			"		if (start != NULL)",
			"			start->prev = NULL;",
			"		free(temp);",
			"	}",
			"}",
			"",
			"// Function to delete from the end",
			"// of the linked list",
			"void deleteEnd()",
			"{",
			"	struct node* temp;",
			"	if (start == NULL)",
			"		printf(\"\\nList is empty\\n\");",
			"	temp = start;",
			"	while (temp->next != NULL)",
			"		temp = temp->next;",
			"	if (start->next == NULL)",
			"		start = NULL;",
			"	else {",
			"		temp->prev->next = NULL;",
			"		free(temp);",
			"	}",
			"}",
			"",
			"// Function to delete from any specified",
			"// position from the linked list",
			"void deletePosition()",
			"{",
			"	int pos, i = 1;",
			"	struct node *temp, *position;",
			"	temp = start;",
			"",
			"	// If DLL is empty",
			"	if (start == NULL)",
			"		printf(\"\\nList is empty\\n\");",
			"",
			"	// Otherwise",
			"	else {",
			"		// Position to be deleted",
			"		printf(\"\\nEnter position : \");",
			"		scanf(\"%d\", &pos);",
			"",
			"		// If the position is the first node",
			"		if (pos == 1) {",
			"			deleteFirst(); // im,proved by Jay Ghughriwala on GeeksforGeeks",
			"			if (start != NULL) {",
			"				start->prev = NULL;",
			"			}",
			"			free(position);",
			"			return;",
			"		}",
			"",
			"		// Traverse till position",
			"		while (i < pos - 1) {",
			"			temp = temp->next;",
			"			i++;",
			"		}",
			"		// Change Links",
			"		position = temp->next;",
			"		if (position->next != NULL)",
			"			position->next->prev = temp;",
			"		temp->next = position->next;",
			"",
			"		// Free memory",
			"		free(position);",
			"	}",
			"}",
			"",
			"// Driver Code",
			"int main()",
			"{",
			"	int choice;",
			"	while (1) {",
			"",
			"		printf(\"\\n\\t1 To see list\\n\");",
			"		printf(\"\\t2 For insertion at\"",
			"			\" starting\\n\");",
			"		printf(\"\\t3 For insertion at\"",
			"			\" end\\n\");",
			"		printf(\"\\t4 For insertion at \"",
			"			\"any position\\n\");",
			"		printf(\"\\t5 For deletion of \"",
			"			\"first element\\n\");",
			"		printf(\"\\t6 For deletion of \"",
			"			\"last element\\n\");",
			"		printf(\"\\t7 For deletion of \"",
			"			\"element at any position\\n\");",
			"		printf(\"\\t8 To exit\\n\");",
			"		printf(\"\\nEnter Choice :\\n\");",
			"		scanf(\"%d\", &choice);",
			"",
			"		switch (choice) {",
			"		case 1:",
			"			traverse();",
			"			break;",
			"		case 2:",
			"			insertAtFront();",
			"			break;",
			"		case 3:",
			"			insertAtEnd();",
			"			break;",
			"		case 4:",
			"			insertAtPosition();",
			"			break;",
			"		case 5:",
			"			deleteFirst();",
			"			break;",
			"		case 6:",
			"			deleteEnd();",
			"			break;",
			"		case 7:",
			"			deletePosition();",
			"			break;",
			"",
			"		case 8:",
			"			exit(1);",
			"			break;",
			"		default:",
			"			printf(\"Incorrect Choice. Try Again \\n\");",
			"			continue;",
			"		}",
			"	}",
			"	return 0;",
			"}",
			""
		],
		"description": "sll help"
	},


	//Double linked list codes...
	"dll help": {
		"prefix": "dll help",
		"body": [
			"// C program for the all operations in",
			"// the Doubly Linked List",
			"#include <stdio.h>",
			"#include <stdlib.h>",
			"",
			"// Linked List Node",
			"struct node {",
			"	int info;",
			"	struct node *prev, *next;",
			"};",
			"struct node* start = NULL;",
			"",
			"// Function to traverse the linked list",
			"void traverse()",
			"{",
			"	// List is empty",
			"	if (start == NULL) {",
			"		printf(\"\\nList is empty\\n\");",
			"		return;",
			"	}",
			"	// Else print the Data",
			"	struct node* temp;",
			"	temp = start;",
			"	while (temp != NULL) {",
			"		printf(\"Data = %d\\n\", temp->info);",
			"		temp = temp->next;",
			"	}",
			"}",
			"",
			"// Function to insert at the front",
			"// of the linked list",
			"void insertAtFront()",
			"{",
			"	int data;",
			"	struct node* temp;",
			"	temp = (struct node*)malloc(sizeof(struct node));",
			"	printf(\"\\nEnter number to be inserted: \");",
			"	scanf(\"%d\", &data);",
			"	temp->info = data;",
			"	temp->prev = NULL;",
			"",
			"	// Pointer of temp will be",
			"	// assigned to start",
			"	temp->next = start;",
			"	start = temp;",
			"}",
			"",
			"// Function to insert at the end of",
			"// the linked list",
			"void insertAtEnd()",
			"{",
			"	int data;",
			"	struct node *temp, *trav;",
			"	temp = (struct node*)malloc(sizeof(struct node));",
			"	temp->prev = NULL;",
			"	temp->next = NULL;",
			"	printf(\"\\nEnter number to be inserted: \");",
			"	scanf(\"%d\", &data);",
			"	temp->info = data;",
			"	temp->next = NULL;",
			"	trav = start;",
			"",
			"	// If start is NULL",
			"	if (start == NULL) {",
			"",
			"		start = temp;",
			"	}",
			"",
			"	// Changes Links",
			"	else {",
			"		while (trav->next != NULL)",
			"			trav = trav->next;",
			"		temp->prev = trav;",
			"		trav->next = temp;",
			"	}",
			"}",
			"",
			"// Function to insert at any specified",
			"// position in the linked list",
			"void insertAtPosition()",
			"{",
			"	int data, pos, i = 1;",
			"	struct node *temp, *newnode;",
			"	newnode = malloc(sizeof(struct node));",
			"	newnode->next = NULL;",
			"	newnode->prev = NULL;",
			"",
			"	// Enter the position and data",
			"	printf(\"\\nEnter position : \");",
			"	scanf(\"%d\", &pos);",
			"	",
			"",
			"	// If start==NULL,",
			"	if (start == NULL) {",
			"		start = newnode;",
			"		newnode->prev = NULL;",
			"		newnode->next = NULL;",
			"	}",
			"",
			"	// If position==1,",
			"	else if (pos == 1) {",
			"	// this is author method its correct but we can simply call insertAtfront() function for this special case",
			"	/* newnode->next = start;",
			"		newnode->next->prev = newnode;",
			"		newnode->prev = NULL;",
			"		start = newnode; */",
			"	// now this is improved by Jay Ghughriwala on geeksforgeeks",
			"	insertAtFront();",
			"	}",
			"",
			"	// Change links",
			"	else {",
			"	printf(\"\\nEnter number to be inserted: \");",
			"	scanf(\"%d\", &data);",
			"	newnode->info = data;",
			"	temp = start;",
			"		while (i < pos - 1) {",
			"			temp = temp->next;",
			"			i++;",
			"		}",
			"		newnode->next = temp->next;",
			"		newnode->prev = temp;",
			"		temp->next = newnode;",
			"		temp->next->prev = newnode;",
			"	}",
			"}",
			"",
			"// Function to delete from the front",
			"// of the linked list",
			"void deleteFirst()",
			"{",
			"	struct node* temp;",
			"	if (start == NULL)",
			"		printf(\"\\nList is empty\\n\");",
			"	else {",
			"		temp = start;",
			"		start = start->next;",
			"		if (start != NULL)",
			"			start->prev = NULL;",
			"		free(temp);",
			"	}",
			"}",
			"",
			"// Function to delete from the end",
			"// of the linked list",
			"void deleteEnd()",
			"{",
			"	struct node* temp;",
			"	if (start == NULL)",
			"		printf(\"\\nList is empty\\n\");",
			"	temp = start;",
			"	while (temp->next != NULL)",
			"		temp = temp->next;",
			"	if (start->next == NULL)",
			"		start = NULL;",
			"	else {",
			"		temp->prev->next = NULL;",
			"		free(temp);",
			"	}",
			"}",
			"",
			"// Function to delete from any specified",
			"// position from the linked list",
			"void deletePosition()",
			"{",
			"	int pos, i = 1;",
			"	struct node *temp, *position;",
			"	temp = start;",
			"",
			"	// If DLL is empty",
			"	if (start == NULL)",
			"		printf(\"\\nList is empty\\n\");",
			"",
			"	// Otherwise",
			"	else {",
			"		// Position to be deleted",
			"		printf(\"\\nEnter position : \");",
			"		scanf(\"%d\", &pos);",
			"",
			"		// If the position is the first node",
			"		if (pos == 1) {",
			"			deleteFirst(); // im,proved by Jay Ghughriwala on GeeksforGeeks",
			"			if (start != NULL) {",
			"				start->prev = NULL;",
			"			}",
			"			free(position);",
			"			return;",
			"		}",
			"",
			"		// Traverse till position",
			"		while (i < pos - 1) {",
			"			temp = temp->next;",
			"			i++;",
			"		}",
			"		// Change Links",
			"		position = temp->next;",
			"		if (position->next != NULL)",
			"			position->next->prev = temp;",
			"		temp->next = position->next;",
			"",
			"		// Free memory",
			"		free(position);",
			"	}",
			"}",
			"",
			"// Driver Code",
			"int main()",
			"{",
			"	int choice;",
			"	while (1) {",
			"",
			"		printf(\"\\n\\t1 To see list\\n\");",
			"		printf(\"\\t2 For insertion at\"",
			"			\" starting\\n\");",
			"		printf(\"\\t3 For insertion at\"",
			"			\" end\\n\");",
			"		printf(\"\\t4 For insertion at \"",
			"			\"any position\\n\");",
			"		printf(\"\\t5 For deletion of \"",
			"			\"first element\\n\");",
			"		printf(\"\\t6 For deletion of \"",
			"			\"last element\\n\");",
			"		printf(\"\\t7 For deletion of \"",
			"			\"element at any position\\n\");",
			"		printf(\"\\t8 To exit\\n\");",
			"		printf(\"\\nEnter Choice :\\n\");",
			"		scanf(\"%d\", &choice);",
			"",
			"		switch (choice) {",
			"		case 1:",
			"			traverse();",
			"			break;",
			"		case 2:",
			"			insertAtFront();",
			"			break;",
			"		case 3:",
			"			insertAtEnd();",
			"			break;",
			"		case 4:",
			"			insertAtPosition();",
			"			break;",
			"		case 5:",
			"			deleteFirst();",
			"			break;",
			"		case 6:",
			"			deleteEnd();",
			"			break;",
			"		case 7:",
			"			deletePosition();",
			"			break;",
			"",
			"		case 8:",
			"			exit(1);",
			"			break;",
			"		default:",
			"			printf(\"Incorrect Choice. Try Again \\n\");",
			"			continue;",
			"		}",
			"	}",
			"	return 0;",
			"}",
			""
		],
		"description": "dll help"
	},
	"LL nodes": {
		"prefix": "dllnode",
		"body": [
			"",
			"struct Node {",
			"    int data;",
			"    struct Node* next;",
			"    struct Node* prev;",
			"};"
		],
		"description": "DLL nodes"
	},
  "dll inempty": {
		"prefix": "dllinem",
		"body": [
			"void selectionsort(int arr[], int n)",
			"{",
			"    int i, j, m;",
			"    for (i = 0; i < n-1; i++)",
			"    {",
			"        m= i;",
			"        for (j = i+1; j < n; j++)",
			"          if (arr[j] < arr[m])",
			"            m = j;",
			"           if(m != i)",
			"            swap(&arr[m], &arr[i]);",
			"    }",
			"}"
		],
		"description": "dll in b"
	},
	"dll drive1": {
		"prefix": "dlldriveinb",
		"body": [
			"int main(){",
			"  struct node* head=NULL;",
			"  head=addToEmpty(head, 45);",
			"  return 0;",
			"}"
		],
		"description": "dll drive"
	},
	"dll ins b": {
		"prefix": "dllinb",
		"body": [
			"struct node* insert_begin(struct node* head, int data){",
			"  struct node* temp=malloc(sizeof(struct node));",
			"  temp-> prev=NULL;",
			"  temp->data=NULL;",
			"  temp->next =NULL;",
			"  temp->next=head;",
			"  head->prev=temp;",
			"  head=temp;",
			"  return head;",
			"}"
		],
		"description": "dll ins b"
	},
	"dll print": {
		"prefix": "dllprint",
		"body": [
			" struct node* ptr;",
			" ptr =head;",
			"  while(ptr !=NULL){",
			"    printf(\"%d\",ptr->data);",
			"    ptr->next;",
			"  }"
		],
		"description": "dll print"
	},
	"dll in e": {
		"prefix": "dlline",
		"body": [
			"struct node*insert_end(struct node* head, int data){",
			"  struct node* temp,*tp;",
			"  struct node* temp=malloc(sizeof(struct node));",
			"  temp->prev=NULL;",
			"  temp->data;",
			"  temp->next=NULL;",
			"  tp=head;",
			"  while(tp->next !=NULL)",
			"  tp=tp->next;",
			"  temp->prev=tp;",
			"  return head;",
			"}"
		],
		"description": "dll in e"
	},
	"dll in pos": {
		"prefix": "dllinp",
		"body": [
			"struct node* insert_pos(struct node* head, int data, int pos){",
			"  struct node* newP=NULL;",
			"  struct node* temp=head;",
			"  struct node* temp2 =NULL;",
			"  newP= addtoempty(newP, data);",
			"  while(pos !=1){",
			"    temp=temp->next;",
			"    pos--;",
			"",
			"  }",
			"  temp2=temp->next;",
			"  temp-> next=newP;",
			"  temp2->prev=newP;",
			"  newP->next=temp2;",
			"  newP->prev=temp;",
			"  return head;",
			"}"
		],
		"description": "dll in pos"
	},
	"dll drive2": {
		"prefix": "dlldrive",
		"body": [
			"int main(){",
			"  struct node* head=NULL;",
			"  struct node* ptr;",
			"  head=addToEmpty(head, 45);",
			"  head =addAtBeg(head,34);",
			"  head= addAtEnd(head, 88);",
			"",
			"  ptr =head;",
			"  while(ptr !=NULL){",
			"    printf(\"%d\",ptr->data);",
			"    ptr->next;",
			"  }",
			"",
			"  return",
			"}"
		],
		"description": "dll drive"
	},
	"dll del f": {
		"prefix": "dlldelf",
		"body": [
			"struct node* delFirst(struct node* head){",
			"  struct node* temp=head;",
			"  head=head->next;",
			"  free(temp);",
			"  temp=NULL;",
			"  head->prev=NULL;",
			"  return head;",
			"}",
			""
		],
		"description": "dll del f"
	},
	"dll del l": {
		"prefix": "dlldell",
		"body": [
			"struct node* dellast(struct node* head){",
			"  struct node* temp=head;",
			"  struct node* temp2;",
			"  while(temp->next !=NULL){",
			"    temp=temp->next;",
			"    temp2=temp->prev;",
			"    temp->next=NULL;",
			"    free(temp);",
			"    return head;",
			"  }",
			"}"
		],
		"description": "dll del l"
	},
	"dll del pos": {
		"prefix": "dlldelp",
		"body": [
			"struct node* del_pos(struct node* head, int pos){",
			"  struct node* temp =head;",
			"  struct node* temp2= NULL;",
			"  if(pos==1){",
			"    head=delfirst(head);",
			"    return head;",
			"",
			"  }",
			"  while(pos>1){",
			"    temp=temp->next;",
			"    pos--;",
			"  }",
			"  if(temp->next==NULL)",
			"  head =delast(head);",
			"  else{",
			"    temp2=temp->prev;",
			"    temp->next =temp->next;",
			"    temp->next->prev=temp2;",
			"    temp=NULL;",
			"  }",
			"  return head;",
			"",
			"}"
		],
		"description": "dll del pos"
	},





	
	// sorti;ng algoritthm
	"algo bubble sort": {
		"prefix": "opalgob",
		"body": [
			"",
			"#include <stdio.h>",
			"void swap(int* xp, int* yp)",
			"{",
			"	int temp = *xp;",
			"	*xp = *yp;",
			"	*yp = temp;",
			"}",
			"void bubbleSort(int arr[], int n)",
			"{",
			"	int i, j;",
			"	for (i = 0; i < n - 1; i++)",
			"",
			"		for (j = 0; j < n - i - 1; j++)",
			"			if (arr[j] > arr[j + 1])",
			"				swap(&arr[j], &arr[j + 1]);",
			"}",
			"void printArray(int arr[], int size)",
			"{",
			"	int i;",
			"	for (i = 0; i < size; i++)",
			"		printf(\"%d \", arr[i]);",
			"	printf(\"\\n\");",
			"}",
			"",
			"int main()",
			"{",
			"	int arr[] = { 7,33,22,45,23,1,4,3 };",
			"	int n = sizeof(arr) / sizeof(arr[0]);",
			"	bubbleSort(arr, n);",
			"	printf(\"Sorted array: \\n\");",
			"	printArray(arr, n);",
			"	return 0;",
			"}",
			""
		],
		"description": "algo bubble sort"
	},
	// Sorting algorithm keys

	"Bubble Sort ": {
		"prefix": "keybubble",
		"body": [
			"void bubblesort(int arr[], int n){",
			"  int i,j;",
			"  for(i=0;i<n-1;i++){",
			"    for(j=0;j<n-i-1;j++){",
			"      if(arr[j]>arr[j+1])",
			"      swap(&arr[j], &arr[j+1]);",
			"    }",
			"  }",
			"}"
		],
		"description": "Bubble Sort"
	},
	"Selection Sort": {
		"prefix": "keyselect",
		"body": [
			"void selectionsort(int arr[], int n)",
			"{",
			"    int i, j, m;",
			"    for (i = 0; i < n-1; i++)",
			"    {",
			"        m= i;",
			"        for (j = i+1; j < n; j++)",
			"          if (arr[j] < arr[m])",
			"            m = j;",
			"           if(m != i)",
			"            swap(&arr[m], &arr[i]);",
			"    }",
			"}"
		],
		"description": "Selection Sort"
	},
	"Insertion Sort": {
		"prefix": "keyinsert",
		"body": [
			"void insertionsort(int arr[], int n)",
			"{",
			"    int i, x, j;",
			"    for (i = 1; i < n; i++)",
			"    {",
			"        x= arr[i];",
			"        j = i - 1;",
			"        while (j >= 0 && arr[j] > x)",
			"        {",
			"            arr[j + 1] = arr[j];",
			"            j = j - 1;",
			"        }",
			"        arr[j + 1] = x;",
			"    }",
			"}",
			" "
		],
		"description": "Insertion Sort"
	},
	"merge Sort": {
		"prefix": "keymerge",
		"body": [
			"void merge(int arr[], int l, int m, int r)",
			"{",
			"    int i, j, k;",
			"    int n1 = m - l + 1;",
			"    int n2 = r - m;",
			"    int L[n1], R[n2];",
			"   for (i = 0; i < n1; i++)",
			"        L[i] = arr[l + i];",
			"    for (j = 0; j < n2; j++)",
			"        R[j] = arr[m + 1 + j];",
			"     i=0,j=0,k=1;",
			"    while (i < n1 && j < n2) {",
			"        if (L[i] <= R[j]) {",
			"            arr[k] = L[i];",
			"            i++;",
			"        }",
			"        else {",
			"            arr[k] = R[j];",
			"            j++;",
			"        }",
			"        k++;",
			"    }",
			"    while (i < n1) {",
			"        arr[k] = L[i];",
			"        i++;",
			"        k++;",
			"    }",
			"    while (j < n2) {",
			"        arr[k] = R[j];",
			"        j++;",
			"        k++;",
			"    }",
			"}",
			"void mergeSort(int arr[], int l, int r)",
			"{",
			"    if (l < r) {",
			"        int m = l + (r - l) / 2;",
			" ",
			"        mergeSort(arr, l, m);",
			"        mergeSort(arr, m + 1, r);",
			" ",
			"        merge(arr, l, m, r);",
			"    }",
			"}"
		],
		"description": "merge Sort"
	},
	"heap Sort": {
		"prefix": "keyheap",
		"body": [
			"void arrange(int arr[], int N, int i)",
			"{",
			"    int largest = i;",
			"    int left = 2 * i + 1;",
			"    int right = 2 * i + 2;",
			"    if (left < N && arr[left] > arr[largest])",
			"        largest = left;",
			"    if (right < N && arr[right] > arr[largest])",
			"        largest = right;",
			"    if (largest != i) {",
			" ",
			"        swap(&arr[i], &arr[largest]);",
			"        arrange(arr, N, largest);",
			"    }",
			"}",
			"void heapSort(int arr[], int N)",
			"{",
			"    for (int i = N / 2 - 1; i >= 0; i--)",
			" ",
			"       arrange (arr, i);",
			"    for (int i = N - 1; i >= 0; i--) {",
			" ",
			"        swap(&arr[0], &arr[i]);",
			"",
			"        arrange(arr, i, 0);",
			"    }",
			"}"
		],
		"description": "heap Sort"
	},
	"Quick Sort": {
		"prefix": "keyquick",
		"body": [
			"int partition(int arr[], int low, int high)",
			"{",
			"    int pivot = arr[high]; ",
			"    int i",
			"        = (low- 1); ",
			"  ",
			"    for (int j = low; j <= high - 1; j++) {",
			"        if (arr[j] < pivot) {",
			"            i++; ",
			"            swap(&arr[i], &arr[j]);",
			"        }",
			"    }",
			"    swap(&arr[i + 1], &arr[high]);",
			"    return (i + 1);",
			"}",
			"  ",
			"void quickSort(int arr[], int low, int high)",
			"{",
			"    if (low < high) {",
			"        int pi = partition(arr, low, high);",
			"        quickSort(arr, low, pi - 1);",
			"        quickSort(arr, pi + 1, high);",
			"    }",
			"}"
		],
		"description": "Quick Sort"
	},
	



	// Single linked list




}